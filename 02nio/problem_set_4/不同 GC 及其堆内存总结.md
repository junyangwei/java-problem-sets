[toc]

# 不同 GC 和 它们的堆内存的总结

| GC 类别 | 简单总结                                                     |
| ------- | ------------------------------------------------------------ |
| 串行 GC | - 它是单线程的垃圾收集器<br />- 进行 GC 期间，所有应用线程都会暂停 (Stop-The-World)<br />- 更加适用于单核 CPU 并且堆内存只有几百 MB 的应用 |
| 并行 GC | - 它是多线程的垃圾收集器<br />- 进行 GC 期间，同样所有应用线程也都会暂停 (Stop-The-World)，并且是多个线程并行地进行垃圾收集 (这也是与串行 GC 的主要差别)<br />- 更加适用于多核 CPU 的服务上 |
| CMS GC  | - 它也是多线程的垃圾收集器<br />- 相比并行 GC，其核心的优化点在于尽可能减少老年代 STW 的暂停时间<br />- 采用分阶段的清理方式，只在“初始标记”和“最终标记”阶段会触发 STW，其余时间与应用线程**并发**的执行<br />- 需要额外注意的是，它的年轻代仍然采用并行 STW 方式进行 GC，会触发全线程的暂停<br />- 更加适用于多核 CPU 的服务器上，并且主要调优目标是降低 GC 停顿导致的系统延迟 |
| G1 GC   | - 它也是多线程的垃圾收集器<br />- 相较与其他垃圾收集器 (串行GC / 并行 GC / CMS GC)，它最大的区别在于其堆的内存结构不再固定地分为年轻代和老年代，而是划分为多个小块 Region (一般是2048个)，每个块都可能被定义为 Eden 区 / Survivor区 / Old区，非常灵活<br />- 它的特点是：<br />    - 会优先清理垃圾最多的区域<br />    - 并且将 STW 停顿的时间和分布，变成可预期且可配置的<br />    - 每次 GC 都不必去收集整个堆空间，而是只处理一部分内存块<br />- 需要注意的是：当堆的整个内存空间不足，并且发生Full GC时，它可能会退化为使用 Serial 来进行垃圾收集<br />- 因此，它非常适合多核 CPU 的服务器上，并且堆内存非常充足的应用 |
|         |                                                              |

# 各个 GC 的详情信息

将从几个方面，对不同的 GC 进行总结，如：启动参数、基本的信息、特点、使用场景

## 串行 GC

串行 GC 简单来说，它是单线程的垃圾收集器，进行 GC 期间，所有应用线程都会暂停 (Stop-The-World)，更加适用于单核 CPU 并且堆内存只有几百 MB 的应用

* 启动参数
  * `-XX:+UseSerialGC`
* 基本描述：
  - 对年轻代使用的是 mark-copy (标记-复制) 算法
  - 对老年代使用的是 mark-sweep-compact (标记-清除-整理) 算法
  - 对年轻代和老年代的垃圾收集器都是单线程的，不能进行并行处理，因此在 GC 期间，会触发全线程的暂停 (Stop-The-World)，停止所有应用线程
* 特点：
  - 这种 GC 算法不能充分利用多核 CPU ，不管有多少 CPU 内核，JVM 在垃圾收集时都只能使用单个核心
  - CPU 利用率高，暂停时间长
* 适用场景
  - 当应用程序比较小，堆内存只需要设置为几百 MB 适用
  - 并且当应用程序部署在单核CPU上时，会更加适用
* ???改进版：`-XX:+UseParNewGC`

## 并行 GC

并行 GC 简单来说，它是多线程的垃圾收集器，进行 GC 期间，同样所有应用线程也都会暂停 (Stop-The-World)，并且是多个线程并行地进行垃圾收集 (这也是与串行 GC 的主要差别)，更加适用于多核 CPU 的服务上

- 启动参数：（三种方式等价）
  - `-XX:+UseParellelGC `
  - `-XX:+UseParellelOldGC`
  - `-XX:+UseParallelGC -XX:+UseParallelOldGC`
- 基本描述：
  - 在 jdk 6, 7, 8 默认运行的就是并行 GC
  - 对年轻代使用的是 mark-copy (标记-复制) 算法
  - 对老年代使用的是 mark-sweep-compact (标记-清除-整理) 算法
  - 在 GC 期间，同样也会触发全线程的暂停 (Stop-The-World)，停止所有应用线程
- 特点
  - 比起串行 GC，并行 GC 在进行垃圾收集的操作中，是并行地使用多个线程来处理
  - 因此在多核 CPU 下执行 GC，所有 CPU 内核都在并行的清理垃圾，总的暂停时间也会短一点，吞吐量也会更高
  - 在两次 GC 周期的间隔期，是没有 GC 线程在运行的，因此不会消耗任何系统资源
  - 可以通过 `-XX:ParallelGCThreads=N` 来指定 GC 线程数，默认值是 CPU 的核心数
- 适用场景：
  - 适用于多核 CPU 的服务器上

## CMS GC

CMS GC 简单来说，它也是多线程的垃圾收集器，相比并行 GC，其核心的优化点在于尽可能减少老年代 STW 的暂停时间，采用分阶段的清理方式，只在“初始标记”和“最终标记”阶段会触发 STW，其余时间与应用线程**并发**的执行；需要额外注意的是，它的年轻代仍然采用并行 STW 方式进行 GC，会触发全线程的暂停；更加适用于多核 CPU 的服务器上，并且主要调优目标是降低 GC 停顿导致的系统延迟

- 启动参数
  - `-XX:+UseConcMarkSweepGC`
- 基本描述
  - 对年轻代采用并行 STW 方式的 mark-copy (标记-复制) 算法，因此对年轻代进行垃圾收集时，会触发全线程的暂停 (Stop-The-World)，停止所有应用线程
  - 对老年代主要使用并发 mark-sweep (标记-清除) 算法，这是与并行GC最大区别点，将拆分成了多个阶段，只有其中两个阶段会触发 STW，其他阶段都会和应用线程一起执行（并发）
  - 在老年代并发的执行 GC 期间，可能会伴随多次年轻代的 Minor GC
- CMS GC 的六个阶段
  - 阶段1：Initial Mark（初始标记）【STW】
    - 该阶段将标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象（老年代单独回收），会触发 STW 暂停所有应用线程
  - 阶段2：Concurrent Mark（并发标记）
    - 该阶段 CMS GC 遍历老年代，标记所有的存活对象，从前一阶段“Initial Mark”找到的根对象开始算起，“并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段
  - 阶段3：Concurrent Preclean（并发预清理）
    - 该阶段同样是与应用线程并发执行的，不需要停止应用线程。因为前一阶段 “并发标记” 与应用程序并发运行，可能有一些引用关系已经发生了改变
    - 如果在“并发标记”过程中引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的卡片标记（Card Marking）
  - 阶段4：Final Mark（最终标记）【STW】
    - 本阶段的目标是完成老年代中所有存活对象的标记，因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度
    - 该阶段伴随STW，也是此次 GC 事件中的最后一次，暂停下来，处理各种复杂的情况
    - 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件
  - 阶段5：Concurrent Sweep（并发清除）
    - 该阶段与应用程序并发执行，不需要 STW 停顿，JVM 在此阶段删除不再使用的对象，并回收它们占用的内存空间
  - 阶段6：Concurrent Reset（并发重置）
    - 该阶段与应用程序并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备
  - Tips：
    - CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程
    - 当然，CMS 也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下 GC 会造成不可预测的暂停时间，特别是堆内存较大的情况下
- 特点
  - CMS GC 设计目的是避免在老年代垃圾收集时出现长时间的停顿，主要通过两种方式来实现这个目的
    - 不对老年代进行整理，而是使用空闲列表 (free-lists) 来管理内存空间的回收
    - 在 mark-and-sweep (标记-清除) 阶段的大部分工作和应用线程一起并发执行
  - 因此，在老年代垃圾收集时，大部分阶段(与应用线程并发执行) 并没有明显的应用线程暂停，不过它仍然会和应用线程争抢 CPU
  - 默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4
- 使用场景
  - 若服务器是多核的 CPU，并且主要调优的目标是降低 GC 停顿导致的系统延迟，那么使用 CMS GC 非常合适
- Tips：区分开“并行”和“并发”两个词的区别

## G1 GC

G1 GC 简单来说，它也是多线程的垃圾收集器，相较与其他垃圾收集器 (串行GC / 并行 GC / CMS GC)，它最大的区别在于其堆的内存结构不再固定地分为年轻代和老年代，而是划分为多个小块 Region (一般是2048个)，每个块都可能被定义为 Eden 区 / Survivor区 / Old区，非常灵活；它的特点是：会优先清理垃圾最多的区域，并且将 STW 停顿的时间和分布，变成可预期且可配置的，每次 GC 都不必去收集整个堆空间，而是只处理一部分内存块；不过需要注意的是，当堆的整个内存空间不足，并且发生Full GC时，它可能会退化为使用 Serial 来进行垃圾收集；因此，它非常适合多核 CPU 的服务器上，并且堆内存非常充足的应用

- 启动参数
  - `-XX:+UseG1GC`
  - `  -XX:MaxGCPauseMillis=50`：设定预期控制 GC 暂停的时间，默认为200毫秒，这里设置为50毫秒
- 基本描述
  - G1 全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它
  - G1 GC 主要涉及目标是：将 STW 停顿的时间和分布，变成可预期且可配置的
  - G1 GC 对不再分成年轻代和老年代，而是划分为多个（通常是2048个）小块：Region
  - 每个小块，一会儿可能被定义成 Eden 区，一会儿可能被指定为  Survivor 区或者 Old 区
- 特点
  - 得益于 G1 GC 将堆内存划分为多个小块，并且动态的分配每个小块是 Eden 区 / Survivor 区 / Old 区
  - 使得 G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理，每次只处理一部分内存块，称为此次 GC 的回收集 (Collection set)
  - 每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块
  - G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数
  - 构建回收集的原则是：垃圾最多的小块会被优先收集，这也是 G1 名称的由来
- 配置参数
  - `-XX:+UseG1GC` 启用 G1 GC
  - `-XX:G1NewSizePercent` 初始年轻代占整个 Java Heap 的大小，默认值为 5%
  - `-XX:G1MaxNewSizePercent` 最大年轻代占整个 Java Heap 的大小，默认值为 60%
  - `-XX:G1HeapRegionSize` 设置每个Region的大小，单位 MB，需要为 1、2、4、8、16、32 中的某个值（2的次幂） ，默认是堆内存的 1/2000，如果这个值设置比较大，那么大对象就可以进入 Region 了
  - `-XX:ConcGCThreads` 与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1/4，减少这个参数的数值可能会提升并行回收的效率，提高系统内部吞吐量。若这个数值过低，参与回收垃圾的线程不足，也会导致并行回收机制耗时加长
  - `-XX:+InitiatingHeapOccupancyPercent` 简称IHOP，G1 内部并行回收循环启动的阈值，默认为 Java Heap的 45%。这个可以理解为老年代使用大于等于 45% 的时候，JVM 会启动垃圾回收，因此这个值非常重要，他决定了在什么时候启动老年代的并行回收
  - `-XX:G1HeapWastePercent` G1 停止回收的最小内存大小，默认是堆大小的 5%，GC 会收集所有的 Region 中的对象，但是如果下降到了 5%，就会停下来不在收集了，也就是说，不必每次回收就把所有的垃圾都处理完，可以预留少量的下次处理，这样也降低了单词消耗的时间
  - `-XX:G1MixedGCCountTarget` 设置并行循环之后需要多少个混合 GC 启动，默认值是 8 个，老年代 Regions 的回收时间通常比年轻代的收集时间要长一些。因此如果混合收集器比较多，可以允许 G1 延长老年代的收集时间
  - `-XX:+G1PrintRegionLivenessInfo` 该参数需要和 `-XX:UnlockDiagnosticVMOptions` 配合启动，打印 JVM 的调试信息，每个 Region 里的对象存货信息
  - `-XX:G1ReservePercent` G1 为了保留一些空间用于年轻代之间的提升，默认值是堆空间的 10%，因为大量执行回收的地方在年轻代（存活时间较短），所以若在应用里面有比较大的堆内存空间、比较多的大对象存活，这里需要保留一些内存
  - `-XX:+G1SummarizeRSetStats` 这也是一个 VM 的调试信息，若启用会在 VM 退出的时候打印出 Rsets 的详细总结信息，若启用 `-XX:+G1SummaryRSetStatsPeriod` 参数，就会阶段性地打印 Rsets 信息
  - `-XX:+G1TraceConcRefinement` 这也是一个 VM 调试信息，若启用，并行回收阶段的日志就会被详细打印出来
  - `-XX:+GCTimeRatio` 这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是9，跟新生代内存的分配比例一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100/(1+GCTimeRatio)。这样如果参数设置为9，则最多10%的时间会花在 GC 工作上。Parallel GC 的默认值是99，表示 1% 的时间被用在 GC 上面，这是因为 Parallel GC 贯穿整个 GC，而 G1 则是根据 Region 来进行划分，不需要全局性扫描整个内存堆
  - `-XX:+UseStringDeduplication` 手动开启 Java String 对象的去重工作，这个是 JDK8u20 版本之后新增的参数，主要用于相同 String 避免重复申请内存，节约 Region 的使用
  - `-XX:MaxGCPauseMills` 预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是200毫秒，G1 会尽量保证控制在这个范围内
- 与其他 GC 差别
  - 并行 GC 在执行 GC 期间会将所有应用线程暂停，全部都用来做 GC 的操作，因此并行 GC 默认 1% 的时间花在GC上是合理的；然而，若
  - G1 GC 跟 CMS GC 一样，大部分情况下 GC 线程和我们的业务线程都是并发执行的，因此它们都适合多核的 CPU上
- 注意事项
  - 在某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的（如下3种情况）
  - 并发模式失败
    - 描述：G1 启动标记周期，但在 Mix GC 之前，老年代就被填满了，这个时候 G1 会放弃标记周期
    - 解决方案：增加堆大小，或者调整周期（例如增加线程 -XX:ConcGCThreads 等）
  - 晋升失败
    - 描述：没有足够的内存供存货对象或晋升对象使用，由此触发了 Full GC (to-space exhausted/to-space overflow)
    - 解决方案：
      - a）增加 -XX:G1ReservePercent 选项的值（并相应增加总的堆大小）增加预留内存量
      - b）通过减少 -XX:InitiatingHeapOccupancyPercent 提前启动标记周期
      - c）通过增加 -XX:ConcGCThreads 选项的值来增加并行标记线程的数目
  - 巨型对象分配失败
    - 描述：当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间
    - 解决方案：增加内存或增大 -XX:G1HeapRegionSize
- 适用场景：
  - 适用于多核 CPU 的服务器上